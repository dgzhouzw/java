package org.example.java.foundational.operator.bit;

/**
 * 无符合右称的使用
 *
 * @author zzw dgzzw1@163.com
 * @version 2022/12/27 20:22
 * @since JDK17
 */
public class UnsignedRightMoveOperator {

	public static void main(String[] args) {
		// 无符号右移动(>>>)：二进制补码向右移动，无论符号位是0还是1，左边都会补0，
		// 负数在进行无符号右移之后就会变成一个正数


		/*
			正整数无符号右移的内存操作过程
			1.188默认是int类型，占据4个字节，二进制的补码是：0000 0000 0000 0000 0000 0000 1011 1100
			2.0000 0000 0000 0000 0000 0000 1011 1100 >>> 2
无符号右移2位结果000000 0000 0000 0000 0000 0000 1011 11
			3.转换成十进制的原码输出
			1011 11 转换成十进制原码结果是47
		 */
		System.out.println("188 >>> 2 = " + (188 >>> 2));

		/*
			负整数无符号右移的内存操作过程
			1.-188默认是int类型，占据4个字节，二进制的原码是：1000 0000 0000 0000 0000 0000 1011 1100
			2.将原码转换成补码:
			原码：1000 0000 0000 0000 0000 0000 1011 1100
			反码: 1111 1111 1111 1111 1111 1111 0100 0011
			补码: 1111 1111 1111 1111 1111 1111 0100 0100
			3.将补码右移2位
			补码: 1111 1111 1111 1111 1111 1111 0100 0100 >>> 2
		    右移2位结果：001111 1111 1111 1111 1111 1111 0100 01
		    4.将补码转换成十进制原码输出 :最终输出结果就是：1073741777


		 */
		System.out.println("-188 >>> 2 = " + (-188 >>> 2));
	}
}

package org.example.java.foundational.operator.bit;

/**
 * 有符号右移的使用
 * @author zzw dgzzw1@163.com
 * @version 2022/12/27 19:51
 * @since JDK17
 */
public class SignedRightMoveOperator {

	public static void main(String[] args) {
		//有符号右移(>>)内存中的操作过程：二进制补码向右移动，左边使用符号位来补齐，符号位是1，那么就补1，如果符号位是0，那么就补0
		//有符号右移(>>)运算规律：右移N位，就是除以2的N次方

		/*
			正整数的右移内存操作过程
			1.32是占据4个字节，因为默认是int类型，计算二进制补码  0000 0000 0000 0000 0000 0000 0010 0000
			2.位运算符操作的是二进制补码 0000 0000 0000 0000 0000 0000 0010 0000 >> 2
			3.向右移动的结果 000000 0000 0000 0000 0000 0000 0010 00
			4.打印输出需要转换成十进制的原码 结果是8
		 */

		System.out.println("32 >> 2 = " + (32 >> 2));

		/*
			负整数的右移内存操作过程
			1.-32是占据4个字节，因为默认是int类型，计算二进制原码  1000 0000 0000 0000 0000 0000 0010 0000
			2.根据原码求补码：
			原码：1000 0000 0000 0000 0000 0000 0010 0000
			反码：1111 1111 1111 1111 1111 1111 1101 1111
			补码：1111 1111 1111 1111 1111 1111 1110 0000
			3.补码右移2位
			1111 1111 1111 1111 1111 1111 1110 0000
右移2位结果： 111111 1111 1111 1111 1111 1111 1110 00
			4.补码转换成二进制原码输出
			补码：111111 1111 1111 1111 1111 1111 1110 00
			反码：111111 1111 1111 1111 1111 1111 1101 11
			原码: 100000 0000 0000 0000 0000 0000 0010 00

		 */
		System.out.println("-32 >> 2 = " + (-32 >> 2));
	}
}
